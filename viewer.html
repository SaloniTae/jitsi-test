<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Viewer — Pin & Fullscreen (8x8 / JaaS)</title>

  <!-- 8x8 / JaaS external API (replace only if you self-host) -->
  <script src="https://8x8.vc/vpaas-magic-cookie-45b14c029c1e43698634a0ad0d0838a9/external_api.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--bg:#000;--panel:#111;--muted:#bbb;--btn:#222;--btnText:#fff}
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Inter,Arial,Helvetica,sans-serif}
    /* outer wrapper to fullscreen (keeps background black) */
    #video-wrap{height:calc(100vh - 56px);position:relative;display:flex;align-items:center;justify-content:center;background:#000}
    #jaas{width:100%;height:100%;background:#000}
    #placeholder{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:var(--muted);z-index:3;font-size:18px;background:#000}
    #controls{height:56px;display:flex;align-items:center;justify-content:center;background:var(--panel);gap:8px;padding:8px}
    button{padding:10px 14px;border-radius:8px;background:var(--btn);color:var(--btnText);border:0;cursor:pointer}
    button[disabled]{opacity:.45;cursor:not-allowed}
    /* ensure iframe fills container */
    #jaas iframe{width:100% !important;height:100% !important;border:0;display:block}
    /* keep black background when fullscreen */
    :fullscreen #video-wrap, :-webkit-full-screen #video-wrap { background:#000; }
    /* small status */
    #status { position: absolute; left:8px; top:8px; z-index:4; font-size:12px; color:#9fbac4; background: rgba(0,0,0,0.35); padding:6px 8px; border-radius:6px; }
  </style>
</head>
<body>
  <div id="video-wrap" aria-live="polite">
    <div id="status">status: initializing…</div>
    <div id="placeholder">Waiting for host to start sharing…</div>
    <div id="jaas" aria-label="meeting"></div>
  </div>

  <div id="controls">
    <button id="fsBtn" disabled>Fullscreen</button>
  </div>

<script>
/*
  viewer.html
  - Paste your ROOM (fully-qualified: <magic>/RoomName) and optionally VIEWER_JWT below
  - This viewer hides all Jitsi buttons and aggressively pins the host/sharer.
*/

const ROOM = "vpaas-magic-cookie-45b14c029c1e43698634a0ad0d0838a9/AyushLive"; // <-- set your room
const VIEWER_JWT = "eyJraWQiOiJ2cGFhcy1tYWdpYy1jb29raWUtNDViMTRjMDI5YzFlNDM2OTg2MzRhMGFkMGQwODM4YTkvNjM4ODg2LVNBTVBMRV9BUFAiLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJhdWQiOiJqaXRzaSIsImlzcyI6ImNoYXQiLCJpYXQiOjE3NTkwNjY0NzQsImV4cCI6MTc1OTA3MzY3NCwibmJmIjoxNzU5MDY2NDY5LCJzdWIiOiJ2cGFhcy1tYWdpYy1jb29raWUtNDViMTRjMDI5YzFlNDM2OTg2MzRhMGFkMGQwODM4YTkiLCJjb250ZXh0Ijp7ImZlYXR1cmVzIjp7ImxpdmVzdHJlYW1pbmciOnRydWUsImZpbGUtdXBsb2FkIjp0cnVlLCJvdXRib3VuZC1jYWxsIjp0cnVlLCJzaXAtb3V0Ym91bmQtY2FsbCI6ZmFsc2UsInRyYW5zY3JpcHRpb24iOnRydWUsImxpc3QtdmlzaXRvcnMiOmZhbHNlLCJyZWNvcmRpbmciOnRydWUsImZsaXAiOmZhbHNlfSwidXNlciI6eyJoaWRkZW4tZnJvbS1yZWNvcmRlciI6ZmFsc2UsIm1vZGVyYXRvciI6ZmFsc2UsIm5hbWUiOiJWaWV3ZXIiLCJpZCI6Imdvb2dsZS1vYXV0aDJ8MTAzOTkzNzcwNTg5NDYyNTY0ODk3IiwiYXZhdGFyIjoiIiwiZW1haWwiOiIifX0sInJvb20iOiIqIn0.OiAxxUP7f9PPL1-HG0j77Yfyc-M0Z7BgwbIaR_AUmf1OsZiOlunOF1Kka8Q-w9Hjb_tySCzj6j2MGw2tdo9DkPWuHMbHi8x8APo162ykhAI2sGYgxeKQsBYo5U52ypN1srhKhWyva4JVV9_-8rAK8wFCy1ZrLT0ntn2moLkdlZ85i-UyHLqhucvN9eFHJD46a-ac61DCF26STpuZRD_h55-g89fZH71NBMoVV9hRbTdsHKH95tDftrJopaSKIRybGGfDZY5wVWl1wPmJkSSiIkN-8mRnJk_MCSHTYPlDyb1qsz0PQ5nXbVnHK-agMTH_OghE22u8ry8vxtd2ZI37HA"; // <-- paste viewer JWT here for tests (leave empty if not using JWT)

const HOST_API_HOST = "8x8.vc"; // JaaS host for the script used above
const viewerName = "Viewer_" + Math.floor(Math.random()*9000 + 1000);

const jaasContainer = document.getElementById('jaas');
const placeholder = document.getElementById('placeholder');
const fsBtn = document.getElementById('fsBtn');
const statusEl = document.getElementById('status');
const videoWrap = document.getElementById('video-wrap');

let api = null;
let joined = false;
let lastPinnedId = null;

// small helpers
function logStatus(s){ statusEl.textContent = 'status: ' + s; console.log('[viewer] ', s); }
function hidePlaceholder(){ placeholder.style.display = 'none'; }
function showPlaceholder(){ placeholder.style.display = 'flex'; }

// init Jitsi
(async function init() {
  logStatus('creating iframe');
  const options = {
    roomName: ROOM,
    parentNode: jaasContainer,
    userInfo: { displayName: viewerName },
    configOverwrite: {
      prejoinPageEnabled: false,
      startWithAudioMuted: true,
      startWithVideoMuted: true,
      disableDeepLinking: true,
      enableWelcomePage: false
    },
    interfaceConfigOverwrite: {
      TOOLBAR_BUTTONS: [],           // hide all toolbar buttons for viewers
      SHOW_JITSI_WATERMARK: false,
      SHOW_BRAND_WATERMARK: false,
      SHOW_POWERED_BY: false
    },
    width: "100%",
    height: "100%"
  };
  if (VIEWER_JWT && VIEWER_JWT.trim()) options.jwt = VIEWER_JWT;

  try {
    api = new JitsiMeetExternalAPI(HOST_API_HOST, options);
    window.__viewerApi = api; // debug handle
    logStatus('iframe created');
  } catch (err) {
    console.error('ExternalAPI init failed', err);
    logStatus('init failed - see console');
    return;
  }

  // attach events we care about
  api.addEventListener('videoConferenceJoined', () => {
    joined = true;
    logStatus('joined');
    fsBtn.disabled = false;
    // try immediate detection/pin
    setTimeout(aggressivePinHost, 400);
    // try to close participant pane if open
    tryCloseParticipantPane();
  });

  api.addEventListener('participantJoined', () => {
    setTimeout(aggressivePinHost, 600);
  });

  api.addEventListener('participantLeft', (p) => {
    if (p && (p.id === lastPinnedId || p.participantId === lastPinnedId)) {
      lastPinnedId = null;
      setTimeout(aggressivePinHost, 500);
    }
  });

  api.addEventListener('screenSharingStatusChanged', (payload) => {
    if (payload && payload.on) {
      hidePlaceholder();
      // payload may include id
      const pid = payload.participantId || payload.id || payload.participant;
      if (pid) { pinParticipant(pid); }
      else { aggressivePinHost(); }
    } else {
      // screen stopped: re-evaluate (host may be webcam)
      setTimeout(aggressivePinHost, 700);
    }
  });

  api.addEventListener('participantVideoStatusChanged', (evt) => {
    const pid = evt && (evt.participantId || evt.id);
    if (evt && (evt.videoStatus === true) && pid && pid !== api.getCurrentUserID()) {
      hidePlaceholder();
      pinParticipant(pid);
    }
  });

  // periodic re-check (helps late joiners)
  setInterval(() => { if (joined) aggressivePinHost(); }, 3500);

  // periodical attempt to close participant pane / filmstrip
  setInterval(tryCloseParticipantPane, 3000);

  // orientation / fullscreen hooks
  document.addEventListener('fullscreenchange', () => {
    logStatus('fullscreen change, fixing layout');
    setTimeout(() => { forceSingleLargeAndPin(); }, 220);
  });
  window.addEventListener('orientationchange', () => {
    logStatus('orientation change, fixing layout');
    setTimeout(() => { forceSingleLargeAndPin(); }, 280);
  });

  logStatus('init complete');
})();


// ========== Host detection & pinning logic ==========

// Try to find the best host candidate using participants info
async function findHostCandidate() {
  if (!api || typeof api.getParticipantsInfo !== 'function') return null;
  try {
    const info = api.getParticipantsInfo();
    const list = (info && typeof info.then === 'function') ? await info : info;
    if (!Array.isArray(list) || list.length === 0) return null;

    // prefer screen sharer
    for (const p of list) {
      const pid = p.participantId || p.id || p.participant;
      if (!pid || pid === api.getCurrentUserID()) continue;
      const features = p.features || {};
      const isSharing = p.isScreensharing || p.isSharingScreen || features.screenSharing;
      if (isSharing) return pid;
    }
    // fallback: prefer participants with video
    for (const p of list) {
      const pid = p.participantId || p.id || p.participant;
      if (!pid || pid === api.getCurrentUserID()) continue;
      if (p.hasVideo || p.videoStatus || p.video) return pid;
    }
    // final fallback: first remote
    const firstRemote = list.find(u => (u.participantId || u.id) && ((u.participantId || u.id) !== api.getCurrentUserID()));
    return firstRemote ? (firstRemote.participantId || firstRemote.id || firstRemote.participant) : null;
  } catch (e) {
    console.warn('findHostCandidate err', e);
    return null;
  }
}

function pinParticipant(pid) {
  if (!pid || !api) return false;
  try { api.executeCommand('setTileView', false); } catch(e){}
  try {
    api.executeCommand('pinParticipant', pid);
    lastPinnedId = pid;
    hidePlaceholder();
    logStatus('pinned: ' + pid);
    return true;
  } catch(e) {
    try { api.executeCommand('setLargeVideoParticipant', pid); lastPinnedId = pid; hidePlaceholder(); return true; } catch(e){}
    console.warn('pin failed', e);
    return false;
  }
}

// Aggressively attempt to locate and pin host (multiple retries)
async function aggressivePinHost(retries = 5, delayMs = 350) {
  for (let i=0;i<retries;i++){
    const pid = await findHostCandidate();
    if (pid) {
      const ok = pinParticipant(pid);
      if (ok) return true;
    }
    await new Promise(r => setTimeout(r, delayMs));
  }
  // not found: keep placeholder visible
  logStatus('no host found yet');
  showPlaceholder();
  return false;
}

// Force single-large view and pin (used on fullscreen/orientation)
async function forceSingleLargeAndPin() {
  try { if (api) api.executeCommand('setTileView', false); } catch(e){}
  await aggressivePinHost(6, 300);
  // attempt a couple of re-pins (mobile timing)
  setTimeout(()=>{ if (lastPinnedId) try { api.executeCommand('pinParticipant', lastPinnedId); } catch(e){} }, 300);
  setTimeout(()=>{ if (lastPinnedId) try { api.executeCommand('pinParticipant', lastPinnedId); } catch(e){} }, 900);
}

// ========== participant pane / filmstrip hiding (best-effort) ==========
function tryCloseParticipantPane() {
  if (!api) return;
  // Try a few commands that exist in some Jitsi builds; wrap in try/catch
  try {
    // 'toggleParticipantsPane' or 'toggleLobby' or 'toggleFilmStrip' might exist in different builds
    api.executeCommand && api.executeCommand('toggleParticipantsPane');
  } catch(e){}
  try { api.executeCommand('toggleFilmStrip'); } catch(e){}
  try { api.executeCommand('hideParticipants'); } catch(e){}
  try { api.executeCommand('toggleFilmStripView'); } catch(e){}
  // also explicitly ask for single-large view
  try { api.executeCommand('setTileView', false); } catch(e){}
}

// ========== Fullscreen button behaviour ==========
fsBtn.addEventListener('click', async () => {
  if (!api || !joined) {
    logStatus('not joined yet — wait');
    return;
  }
  const el = videoWrap;
  try {
    if (el.requestFullscreen) await el.requestFullscreen();
    else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
    else if (el.msRequestFullscreen) await el.msRequestFullscreen();
  } catch (err) {
    console.warn('fullscreen failed', err);
  }
});

// expose small debug helper
window.__viewerHelpers = { aggressivePinHost, forceSingleLargeAndPin, tryCloseParticipantPane };

// small poll to try pinning if the placeholder is stuck (helps late viewers)
setInterval(() => {
  if (api && joined) aggressivePinHost(2, 250).catch(()=>{});
}, 3500);
</script>
</body>
</html>
