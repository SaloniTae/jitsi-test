<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Viewer — Protected embed (active lock)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --bg:#000; --text:#e6f0f3; }
  html,body{height:100%; margin:0; font-family:system-ui,Arial,Helvetica,sans-serif; background:var(--bg); color:var(--text); overflow:hidden;}
  #jaas {height:100vh; background:var(--bg); position:relative; overflow:hidden; width:100vw;}
  .viewer-controls { position:absolute; right:12px; top:12px; z-index:9999; display:none; gap:8px; align-items:center; }
  .viewer-controls button { background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.06); padding:8px 10px; color:var(--text); border-radius:6px; cursor:pointer; font-size:13px; }
  #status { position:absolute; left:12px; top:12px; z-index:9999; font-size:13px; color: #9fb2b8; }
  #meetFrame { width:100%; height:100vh; border:0; display:block; background:var(--bg); }
</style>
</head>
<body>
  <div id="jaas" aria-label="meeting">
    <div id="status">Connecting…</div>
    <div class="viewer-controls" id="viewerControls">
      <button id="btnFullscreen">Fullscreen</button>
    </div>
  </div>

<script>
(function(){
  // CONFIG
  const ROOM = "AyushLive";
  const SERVICE_BASE = ""; // empty means same origin (served from same server)
  const REQUEST_JOIN_PATH = '/api/request-join';
  const HEARTBEAT_PATH = '/api/heartbeat';
  const LEAVE_PATH = '/api/leave';

  const HEARTBEAT_INTERVAL = 20 * 1000; // ms (must match server HEARTBEAT_INTERVAL)
  const STATUS = document.getElementById('status');
  const viewerControls = document.getElementById('viewerControls');
  let currentJti = null;
  let heartbeatTimer = null;
  let iframe = null;

  function setStatus(t) { if (STATUS) STATUS.textContent = t; }

  // request ephemeral join URL and embed it
  async function requestAndEmbed() {
    setStatus('Requesting secure join URL…');
    try {
      const resp = await fetch(REQUEST_JOIN_PATH, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ room: ROOM })
      });
      if (!resp.ok) {
        const txt = await resp.text().catch(()=>null);
        console.error('request failed', resp.status, txt);
        setStatus('Failed to get join link');
        return;
      }
      const data = await resp.json();
      if (!data || !data.joinUrl) { setStatus('Invalid response'); return; }
      // joinUrl is absolute; extract jti
      const url = new URL(data.joinUrl, window.location.origin);
      currentJti = url.pathname.split('/').pop();

      embedJoinUrl(data.joinUrl);
      startHeartbeat();
    } catch (e) {
      console.error('requestAndEmbed error', e);
      setStatus('Network error');
      setTimeout(requestAndEmbed, 3000);
    }
  }

  function embedJoinUrl(joinUrl) {
    setStatus('Embedding meeting…');
    const jaas = document.getElementById('jaas');
    jaas.innerHTML = '';
    iframe = document.createElement('iframe');
    iframe.id = 'meetFrame';
    iframe.src = joinUrl;
    iframe.allow = 'camera; microphone; fullscreen';
    iframe.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups';
    jaas.appendChild(iframe);
    if (viewerControls) viewerControls.style.display = 'flex';
    setStatus('');
  }

  // heartbeat pings to keep link active
  async function heartbeatPing() {
    if (!currentJti) return;
    try {
      await fetch(HEARTBEAT_PATH, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ jti: currentJti })
      });
      // no UI change needed if ok
    } catch (e) {
      console.warn('heartbeat failed', e);
    }
  }

  function startHeartbeat() {
    stopHeartbeat();
    heartbeatTimer = setInterval(heartbeatPing, HEARTBEAT_INTERVAL);
    // send first immediately
    heartbeatPing();
  }
  function stopHeartbeat() {
    if (heartbeatTimer) { clearInterval(heartbeatTimer); heartbeatTimer = null; }
  }

  // explicit leave to free the link
  async function sendLeave() {
    if (!currentJti) return;
    try {
      await fetch(LEAVE_PATH, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ jti: currentJti })
      });
    } catch (e) { /* ignore */ }
  }

  // Attempt to gracefully release on page unload
  window.addEventListener('beforeunload', function(e) {
    // best-effort synchronous fetch is not reliable; we call navigator.sendBeacon if available
    if (currentJti && navigator.sendBeacon) {
      const payload = JSON.stringify({ jti: currentJti });
      navigator.sendBeacon(LEAVE_PATH, payload);
    } else {
      // fallback: attempt fetch but may not complete
      sendLeave();
    }
    stopHeartbeat();
  });

  // wire fullscreen
  document.getElementById('btnFullscreen').addEventListener('click', () => {
    const el = document.getElementById('jaas');
    if (el.requestFullscreen) el.requestFullscreen().catch(()=>{});
    else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen().catch(()=>{});
  });

  // boot
  window.addEventListener('load', () => {
    requestAndEmbed();
  });

})();
</script>
</body>
</html>
