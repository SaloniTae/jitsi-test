<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Viewer — Protected embed (ephemeral join)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root { --bg:#000; --text:#e6f0f3; }
  html,body{height:100%; margin:0; font-family:system-ui,Arial,Helvetica,sans-serif; background:var(--bg); color:var(--text); overflow:hidden;}
  #jaas {height:100vh; background:var(--bg); position:relative; overflow:hidden; width:100vw;}
  .viewer-controls { position:absolute; right:12px; top:12px; z-index:9999; display:none; gap:8px; align-items:center; }
  .viewer-controls button { background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.06); padding:8px 10px; color:var(--text); border-radius:6px; cursor:pointer; font-size:13px; }
  #status { position:absolute; left:12px; top:12px; z-index:9999; font-size:13px; color: #9fb2b8; }
  .force-landscape {
    position: fixed !important;
    top: 50% !important;
    left: 50% !important;
    width: 100vh !important;
    height: 100vw !important;
    transform-origin: center center !important;
    transform: translate(-50%, -50%) rotate(90deg) !important;
    z-index: 99999 !important;
    background: var(--bg) !important;
    overflow: hidden !important;
  }
  /* iframe filler */
  #meetFrame { width:100%; height:100vh; border:0; display:block; background:var(--bg); }
</style>
</head>
<body>
  <div id="jaas" aria-label="meeting">
    <div id="status">Connecting…</div>
    <div class="viewer-controls" id="viewerControls">
      <button id="btnFullscreen">Fullscreen</button>
    </div>
  </div>

<script>
(function(){
  // ===== CONFIG =====
  // ROOM may be kept here for compatibility. Best practice: have the server infer room from session.
  const ROOM = "AyushLive"; // optional - server can ignore and pick based on session
  // Set this to your Render service base URL (e.g. https://your-service.onrender.com)
  const SERVICE_BASE = "https://oor-islive.onrender.com";

  // If you use cookie-based sessions (recommended), use credentials: 'include'
  // If you use header based auth (e.g., x-session-id), set HEADERS below.
  const FETCH_OPTS = {
    method: 'POST',
    credentials: 'include',
    headers: {
      'Content-Type': 'application/json'
      // 'x-session-id': 'real-session-id-if-you-use-this' // uncomment if you use header auth
    },
    body: JSON.stringify({ room: ROOM })
  };

  // Ephemeral /join TTL on server (just for UI text)
  const EXPECTED_TTL = 90; // seconds - match server

  // ===== UI helpers =====
  const statusEl = document.getElementById('status');
  const viewerControls = document.getElementById('viewerControls');

  function setStatus(text) {
    if (statusEl) statusEl.textContent = text;
  }

  // ----- Orientation & Fullscreen helpers (kept from your original) -----
  function isMobileOrTouchSmall() {
    try {
      const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
      const smallWidth = window.innerWidth <= 900;
      return hasTouch && smallWidth;
    } catch (e) { return false; }
  }
  let isForcingLandscapeViaCSS = false;
  function applyCssLandscapeFallback(){
    if (!isMobileOrTouchSmall()) return;
    if (isForcingLandscapeViaCSS) return;
    const jaas = document.getElementById('jaas');
    if (!jaas) return;
    document.body.style.overflow = 'hidden';
    jaas.classList.add('force-landscape');
    isForcingLandscapeViaCSS = true;
  }
  function removeCssLandscapeFallback(){
    if (!isForcingLandscapeViaCSS) return;
    const jaas = document.getElementById('jaas');
    if (!jaas) return;
    jaas.classList.remove('force-landscape');
    document.body.style.overflow = '';
    isForcingLandscapeViaCSS = false;
  }
  async function tryLockOrientation(orientation) {
    if (!orientation) return Promise.reject('No orientation API');
    if (screen.orientation && typeof screen.orientation.lock === 'function') {
      return screen.orientation.lock(orientation);
    }
    const maybeLock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;
    if (typeof maybeLock === 'function') {
      try {
        const ok = maybeLock.call(screen, orientation);
        return (ok && typeof ok.then === 'function') ? ok : Promise.resolve(ok);
      } catch (e) { return Promise.reject(e); }
    }
    return Promise.reject('Orientation lock not supported');
  }
  async function tryUnlockOrientation(){
    try {
      if (screen.orientation && typeof screen.orientation.unlock === 'function') {
        screen.orientation.unlock();
      } else if (screen.unlockOrientation) {
        screen.unlockOrientation();
      } else if (screen.mozUnlockOrientation) {
        screen.mozUnlockOrientation();
      } else if (screen.msUnlockOrientation) {
        screen.msUnlockOrientation();
      }
    } catch(e){ /* ignore */ }
  }

  async function enterFullscreenAndLandscape(){
    const el = document.getElementById('jaas');
    if (!el) return;
    try {
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      else if (el.msRequestFullscreen) await el.msRequestFullscreen();
    } catch(e){}
    try {
      await tryLockOrientation('landscape');
      removeCssLandscapeFallback();
    } catch (err) {
      applyCssLandscapeFallback();
    }
  }
  async function exitFullscreenAndRestore(){
    try {
      if (document.exitFullscreen) await document.exitFullscreen();
      else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
      else if (document.msExitFullscreen) await document.msExitFullscreen();
    } catch(e){}
    tryUnlockOrientation();
    removeCssLandscapeFallback();
  }
  function toggleFullscreen(){
    if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
      enterFullscreenAndLandscape();
    } else {
      exitFullscreenAndRestore();
    }
  }
  document.addEventListener('fullscreenchange', ()=>{ if (!document.fullscreenElement) { tryUnlockOrientation(); removeCssLandscapeFallback(); }});
  document.addEventListener('webkitfullscreenchange', ()=>{ if (!document.webkitFullscreenElement) { tryUnlockOrientation(); removeCssLandscapeFallback(); }});
  document.addEventListener('msfullscreenchange', ()=>{ if (!document.msFullscreenElement) { tryUnlockOrientation(); removeCssLandscapeFallback(); }});

  // ===== Core: request ephemeral join and embed iframe =====
  async function requestAndEmbed() {
    setStatus('Requesting secure join URL…');
    try {
      const resp = await fetch(`${SERVICE_BASE.replace(/\/$/,'')}/api/request-join`, FETCH_OPTS);
      if (!resp.ok) {
        const err = await resp.text().catch(()=>null);
        console.error('request-join failed', resp.status, err);
        setStatus('Unable to get join link (server rejected).');
        return;
      }
      const data = await resp.json();
      if (!data || !data.joinUrl) {
        console.error('unexpected response', data);
        setStatus('Failed to get join link.');
        return;
      }

      setStatus('Embedding meeting…');

      // Create an iframe that points to the ephemeral join URL (server-side will inject provider iframe)
      const iframe = document.createElement('iframe');
      iframe.id = 'meetFrame';
      iframe.src = data.joinUrl;
      // allow camera/mic and fullscreen — the join page served by server will itself embed provider iframe
      iframe.allow = 'camera; microphone; fullscreen; clipboard-write';
      // Sandbox flags: allow-same-origin so the server-page can run scripts; allow-scripts for provider bootstrap.
      // If your join page is on a different origin and you need full camera access, you may need to adjust sandbox or avoid sandbox.
      iframe.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups';

      // insert iframe into container
      const jaas = document.getElementById('jaas');
      jaas.innerHTML = ''; // clear loading state
      jaas.appendChild(iframe);

      // show controls
      if (viewerControls) viewerControls.style.display = 'flex';
      setStatus('Joined — enjoying the meeting');

      // Auto-hide status after short while
      setTimeout(()=> setStatus(''), 4000);

      // OPTIONAL: set a timeout to blank iframe after some time (defensive)
      setTimeout(()=> {
        try { iframe.src = 'about:blank'; } catch(e){}
      }, Math.max(5*60*1000, (data.ttl ? data.ttl*1000 : 90*1000) + 90*1000)); // blank after TTL + buffer or 5min

    } catch (err) {
      console.error('requestAndEmbed error', err);
      setStatus('Network error — retrying in 3s…');
      setTimeout(()=> requestAndEmbed(), 3000);
    }
  }

  // ===== Boot =====
  window.addEventListener('load', ()=> {
    // wire fullscreen btn
    const fsBtn = document.getElementById('btnFullscreen');
    if (fsBtn) fsBtn.addEventListener('click', toggleFullscreen);

    // start the ephemeral join flow
    requestAndEmbed();
  });

})();
</script>
</body>
</html>
